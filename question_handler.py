import random
import asyncio
from config import QUESTIONS, QUESTION_TIMEOUT

class QuestionHandler:
    def __init__(self):
        self.questions = QUESTIONS.copy()
        random.shuffle(self.questions)
        self.current_question_index = 0
        self.questions_asked = []

    def reset(self):
        """Reset the question handler for a new game"""
        self.questions = QUESTIONS.copy()
        random.shuffle(self.questions)
        self.current_question_index = 0
        self.questions_asked = []

    def get_next_question(self):
        """Get the next question from the pool"""
        if self.current_question_index >= len(self.questions):
            # If we've gone through all questions, reshuffle
            random.shuffle(self.questions)
            self.current_question_index = 0
        
        question_data = self.questions[self.current_question_index]
        self.current_question_index += 1
        self.questions_asked.append(question_data)
        return question_data

    def get_random_question(self):
        """Get a random question that hasn't been asked yet"""
        available_questions = [q for q in self.questions if q not in self.questions_asked]
        if not available_questions:
            # If all questions have been asked, reset
            available_questions = self.questions
            self.questions_asked = []
        
        question_data = random.choice(available_questions)
        self.questions_asked.append(question_data)
        return question_data

    def check_answer(self, user_answer, correct_answer):
        """Check if the user's answer is correct"""
        # Normalize answers for comparison (lowercase, strip spaces)
        user_answer = user_answer.strip().lower()
        correct_answer = correct_answer.strip().lower()
        
        return user_answer == correct_answer

    async def wait_for_answer(self, bot, ctx, question_data, game_state, timeout=QUESTION_TIMEOUT):
        """Wait for an answer to a question within the timeout period"""
        question_text = question_data["question"]
        correct_answer = question_data["answer"]
        
        start_time = asyncio.get_event_loop().time()
        
        # Function to check if a message is a valid answer attempt
        def check_answer(message):
            # Only accept answers from registered players in the current game
            if game_state.game_mode == "ŸÅÿ±ÿØŸä":
                return True  # In solo mode, anyone can answer
            
            elif game_state.game_mode == "ÿ™ÿ≠ÿØŸä":
                return message.author.name in game_state.players
            
            elif game_state.game_mode == "ÿ™ŸäŸÖ":
                return (message.author.name in game_state.red_team or 
                        message.author.name in game_state.blue_team)
            
            return False
        
        await ctx.send(f"ÿßŸÑÿ≥ÿ§ÿßŸÑ: {question_text}")
        
        try:
            while True:
                # Calculate remaining time
                elapsed = asyncio.get_event_loop().time() - start_time
                remaining = timeout - elapsed
                
                if remaining <= 0:
                    await ctx.send(f"ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™! ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸáŸä: {correct_answer}")
                    return None, None, timeout  # No one answered in time
                
                try:
                    # Wait for a message that could be an answer
                    message = await bot.wait_for('message', timeout=remaining, check=check_answer)
                    
                    # Check if the answer is correct
                    if self.check_answer(message.content, correct_answer):
                        # Calculate how long it took to answer
                        answer_time = asyncio.get_event_loop().time() - start_time
                        
                        # Determine points based on answer time
                        points = 10 if answer_time <= 5 else 5
                        
                        # Don't send message here, we'll do it in the caller to provide more details
                        return message.author.name, points, answer_time
                    
                    # Wrong answer, continue waiting
                except asyncio.TimeoutError:
                    # This inner timeout means no one answered within the remaining time
                    await ctx.send(f"ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™! ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸáŸä: {correct_answer}")
                    return None, None, timeout
        
        except Exception as e:
            print(f"Error waiting for answer: {e}")
            await ctx.send(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©. ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸáŸä: {correct_answer}")
            return None, None, timeout

    async def handle_golden_question(self, bot, ctx, game_state):
        """Handle a golden question with 50 point reward"""
        question_data = self.get_random_question()
        
        await ctx.send("‚≠ê‚≠ê‚≠ê Golden Question! ‚≠ê‚≠ê‚≠ê")
        await ctx.send("ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ÿ™ŸÖŸÜÿ≠ŸÉ 50 ŸÜŸÇÿ∑ÿ©!")
        
        player_name, _, answer_time = await self.wait_for_answer(bot, ctx, question_data, game_state)
        
        if player_name:
            if game_state.game_mode == "ŸÅÿ±ÿØŸä":
                game_state.player_points[player_name] = game_state.player_points.get(player_name, 0) + 50
            
            elif game_state.game_mode == "ÿ™ÿ≠ÿØŸä":
                game_state.player_points[player_name] = game_state.player_points.get(player_name, 0) + 50
            
            elif game_state.game_mode == "ÿ™ŸäŸÖ":
                # ÿ™ÿ£ŸÉÿØ ŸÖŸÜ Ÿàÿ¨ŸàÿØ ŸÇÿßÿ¶ŸÖÿ© ŸÜŸÇÿßÿ∑ ŸÅÿ±ÿØŸäÿ©
                if 'player_individual_points' not in game_state.__dict__:
                    game_state.player_individual_points = {}
                
                if player_name in game_state.red_team:
                    # ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÜŸÇÿßÿ∑ ŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ±
                    game_state.red_team_points += 50
                    # ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑŸÅÿ±ÿØŸäÿ© ŸÑŸÑÿßÿπÿ®
                    game_state.player_individual_points[player_name] = game_state.player_individual_points.get(player_name, 0) + 50
                    
                    await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ÿ≠ÿµŸÑ ÿπŸÑŸâ 50 ŸÜŸÇÿ∑ÿ© ÿ•ÿ∂ÿßŸÅŸäÿ©!")
                    await ctx.send(f"‚≠ê {player_name} ÿ≠ÿµŸÑ ÿπŸÑŸâ 50 ŸÜŸÇÿ∑ÿ© ŸÅÿ±ÿØŸäÿ©! ŸÑÿØŸäŸá ÿßŸÑÿ¢ŸÜ {game_state.player_individual_points[player_name]} ŸÜŸÇÿ∑ÿ© ‚≠ê")
                
                elif player_name in game_state.blue_team:
                    # ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÜŸÇÿßÿ∑ ŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ
                    game_state.blue_team_points += 50
                    # ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑŸÅÿ±ÿØŸäÿ© ŸÑŸÑÿßÿπÿ®
                    game_state.player_individual_points[player_name] = game_state.player_individual_points.get(player_name, 0) + 50
                    
                    await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ÿ≠ÿµŸÑ ÿπŸÑŸâ 50 ŸÜŸÇÿ∑ÿ© ÿ•ÿ∂ÿßŸÅŸäÿ©!")
                    await ctx.send(f"‚≠ê {player_name} ÿ≠ÿµŸÑ ÿπŸÑŸâ 50 ŸÜŸÇÿ∑ÿ© ŸÅÿ±ÿØŸäÿ©! ŸÑÿØŸäŸá ÿßŸÑÿ¢ŸÜ {game_state.player_individual_points[player_name]} ŸÜŸÇÿ∑ÿ© ‚≠ê")

    async def handle_test_of_fate(self, bot, ctx, game_state):
        """Handle a Test of Fate series of 5 questions"""
        # ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÖÿµŸäÿ± ŸÖÿ™ÿßÿ≠ ŸÅŸÇÿ∑ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ≠ÿØŸä ŸàÿßŸÑŸÅÿ±ŸÇ
        if game_state.game_mode == "ŸÅÿ±ÿØŸä":
            await ctx.send("The Test of Fate ÿ∫Ÿäÿ± ŸÖÿ™ÿßÿ≠ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑŸÑÿπÿ® ÿßŸÑŸÅÿ±ÿØŸä!")
            return

        await ctx.send("üî•üî•üî• The Test of Fate! üî•üî•üî•")
        await ctx.send("5 ÿ£ÿ≥ÿ¶ŸÑÿ© ŸÖÿ™ÿ™ÿßÿ®ÿπÿ©. ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©: +10 ŸÜŸÇÿßÿ∑. ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿÆÿßÿ∑ÿ¶ÿ©: -5 ŸÜŸÇÿßÿ∑.")
        await ctx.send("ŸÑÿß Ÿäÿ™ŸÖ ÿÆÿµŸÖ ŸÜŸÇÿßÿ∑ ÿπŸÜÿØ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑŸàŸÇÿ™ ÿ®ÿØŸàŸÜ ÿ•ÿ¨ÿßÿ®ÿ©.")
        
        # Initialize temporary points for each player/team
        temp_points = {}
        incorrect_answers = {}  # ÿ™ÿ™ÿ®ÿπ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿßŸÑÿÆÿßÿ∑ÿ¶ÿ© ŸÑŸÉŸÑ ŸÑÿßÿπÿ®
        
        for question_num in range(1, 6):
            question_data = self.get_random_question()
            await ctx.send(f"ÿ≥ÿ§ÿßŸÑ {question_num}/5:")
            
            try:
                # ŸÇÿßÿ¶ŸÖÿ© ŸÑŸÑÿßÿπÿ®ŸäŸÜ ÿßŸÑÿ∞ŸäŸÜ ÿ£ÿ¨ÿßÿ®Ÿàÿß ÿ•ÿ¨ÿßÿ®ÿ© ÿÆÿßÿ∑ÿ¶ÿ© ŸÅŸä Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ§ÿßŸÑ
                wrong_players = []
                
                # ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ŸÑŸÖÿØÿ© 10 ÿ´ŸàÿßŸÜŸç
                start_time = asyncio.get_event_loop().time()
                correct_player = None
                
                while asyncio.get_event_loop().time() - start_time < 10 and not correct_player:
                    remaining_time = 10 - (asyncio.get_event_loop().time() - start_time)
                    
                    try:
                        def check_answer(message):
                            # ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑÿ±ÿ≥ÿßÿ¶ŸÑ ÿßŸÑÿ™Ÿä ÿ™ÿ®ÿØÿ£ ÿ®ŸÄ "!" ŸÑÿ£ŸÜŸáÿß ŸÇÿØ ÿ™ŸÉŸàŸÜ ÿ£ŸàÿßŸÖÿ± ŸÑŸÑÿ®Ÿàÿ™
                            if message.content.startswith('!'):
                                return False
                                
                            # ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑŸÑÿßÿπÿ® ÿ•ÿ∞ÿß ŸÉÿßŸÜ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑŸÑÿπÿ® ÿßŸÑŸÖŸÜÿßÿ≥ÿ®
                            if game_state.game_mode == "ÿ™ÿ≠ÿØŸä" and message.author.name not in game_state.players:
                                return False
                            
                            if game_state.game_mode == "ÿ™ŸäŸÖ" and message.author.name not in game_state.red_team and message.author.name not in game_state.blue_team:
                                return False
                                
                            # ÿ™ÿ¨ÿßŸáŸÑ ÿßŸÑŸÑÿßÿπÿ®ŸäŸÜ ÿßŸÑÿ∞ŸäŸÜ ÿ≥ÿ®ŸÇ Ÿàÿ£ÿ¨ÿßÿ®Ÿàÿß ÿ•ÿ¨ÿßÿ®ÿ© ÿÆÿßÿ∑ÿ¶ÿ© ÿπŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ§ÿßŸÑ
                            if message.author.name in wrong_players:
                                return False
                                
                            return True
                            
                        message = await bot.wait_for('message', timeout=remaining_time, check=check_answer)
                        
                        # ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©
                        if self.check_answer(message.content, question_data["answer"]):
                            # ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©
                            correct_player = message.author.name
                            temp_points[correct_player] = temp_points.get(correct_player, 0) + 10
                            await ctx.send(f"ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ© ŸÖŸÜ {correct_player}! +10 ŸÜŸÇÿßÿ∑")
                        else:
                            # ÿ•ÿ¨ÿßÿ®ÿ© ÿÆÿßÿ∑ÿ¶ÿ©ÿå ÿÆÿµŸÖ 5 ŸÜŸÇÿßÿ∑
                            wrong_player = message.author.name
                            wrong_players.append(wrong_player)
                            incorrect_answers[wrong_player] = incorrect_answers.get(wrong_player, 0) + 1
                            
                            if game_state.game_mode == "ÿ™ÿ≠ÿØŸä":
                                # ÿÆÿµŸÖ 5 ŸÜŸÇÿßÿ∑ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿ™ÿ≠ÿØŸä
                                game_state.player_points[wrong_player] = max(0, game_state.player_points.get(wrong_player, 0) - 5)
                                await ctx.send(f"ÿ•ÿ¨ÿßÿ®ÿ© ÿÆÿßÿ∑ÿ¶ÿ© ŸÖŸÜ {wrong_player}. -5 ŸÜŸÇÿßÿ∑.")
                            elif game_state.game_mode == "ÿ™ŸäŸÖ":
                                # ÿ™ÿ≠ÿØŸäÿØ ÿßŸÑŸÅÿ±ŸäŸÇ
                                if wrong_player in game_state.red_team:
                                    game_state.red_team_points = max(0, game_state.red_team_points - 5)
                                    await ctx.send(f"ÿ•ÿ¨ÿßÿ®ÿ© ÿÆÿßÿ∑ÿ¶ÿ© ŸÖŸÜ {wrong_player}. -5 ŸÜŸÇÿßÿ∑ ŸÑŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ±.")
                                elif wrong_player in game_state.blue_team:
                                    game_state.blue_team_points = max(0, game_state.blue_team_points - 5)
                                    await ctx.send(f"ÿ•ÿ¨ÿßÿ®ÿ© ÿÆÿßÿ∑ÿ¶ÿ© ŸÖŸÜ {wrong_player}. -5 ŸÜŸÇÿßÿ∑ ŸÑŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ.")
                    
                    except asyncio.TimeoutError:
                        # ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÖÿ™ÿ®ŸÇŸäÿå ŸÑŸÉŸÜ ŸÑÿß ÿ≤ÿßŸÑ ÿßŸÑŸàŸÇÿ™ ÿßŸÑŸÉŸÑŸä ŸÖÿ™ÿßÿ≠Ÿãÿß
                        continue
                
                # ÿ•ÿ∞ÿß ŸÑŸÖ Ÿäÿ¨ÿ® ÿ£ÿ≠ÿØ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©
                if not correct_player:
                    await ctx.send(f"ŸÑŸÖ Ÿäÿ¨ÿ® ÿ£ÿ≠ÿØ ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ© ÿπŸÑŸâ Ÿáÿ∞ÿß ÿßŸÑÿ≥ÿ§ÿßŸÑ. ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸáŸä: {question_data['answer']}")
            
            except Exception as e:
                print(f"ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿπÿßŸÑÿ¨ÿ© ÿ≥ÿ§ÿßŸÑ ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÖÿµŸäÿ±: {e}")
                await ctx.send("ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ŸÖÿπÿßŸÑÿ¨ÿ© ÿßŸÑÿ≥ÿ§ÿßŸÑ. ÿßŸÑÿßŸÜÿ™ŸÇÿßŸÑ ÿ•ŸÑŸâ ÿßŸÑÿ≥ÿ§ÿßŸÑ ÿßŸÑÿ™ÿßŸÑŸä.")
            
            # ÿßŸÜÿ™ÿ∏ÿßÿ± ŸÇÿµŸäÿ± ÿ®ŸäŸÜ ÿßŸÑÿ£ÿ≥ÿ¶ŸÑÿ©
            await asyncio.sleep(2)
        
        # ÿ™ÿ∑ÿ®ŸäŸÇ ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑŸÜŸáÿßÿ¶Ÿäÿ©
        if game_state.game_mode == "ÿ™ÿ≠ÿØŸä":
            # ÿ•ÿ∏Ÿáÿßÿ± ŸÜÿ™ÿßÿ¶ÿ¨ ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑŸÖŸÉÿ™ÿ≥ÿ®ÿ©
            for player, points in temp_points.items():
                await ctx.send(f"{player} ŸÉÿ≥ÿ® {points} ŸÜŸÇÿ∑ÿ© ŸÖŸÜ ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÖÿµŸäÿ±!")
                
            # ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑŸÖÿÆÿµŸàŸÖÿ©
            for player, count in incorrect_answers.items():
                penalty = min(count * 5, game_state.player_points.get(player, 0))
                if penalty > 0:
                    await ctx.send(f"{player} ÿÆÿ≥ÿ± {penalty} ŸÜŸÇÿ∑ÿ© ÿ®ÿ≥ÿ®ÿ® ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿßŸÑÿÆÿßÿ∑ÿ¶ÿ©!")
        
        elif game_state.game_mode == "ÿ™ŸäŸÖ":
            red_total = 0
            blue_total = 0
            
            # ÿ≠ÿ≥ÿßÿ® ŸÜŸÇÿßÿ∑ ŸÉŸÑ ŸÅÿ±ŸäŸÇ ŸÖŸÜ ÿßŸÑÿ•ÿ¨ÿßÿ®ÿßÿ™ ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ©
            for player, points in temp_points.items():
                if player in game_state.red_team:
                    red_total += points
                elif player in game_state.blue_team:
                    blue_total += points
            
            # ÿ•ÿ∏Ÿáÿßÿ± ÿßŸÑŸÜÿ™ÿßÿ¶ÿ¨
            if red_total > 0:
                await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ŸÉÿ≥ÿ® {red_total} ŸÜŸÇÿ∑ÿ© ŸÖŸÜ ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÖÿµŸäÿ±!")
            
            if blue_total > 0:
                await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ŸÉÿ≥ÿ® {blue_total} ŸÜŸÇÿ∑ÿ© ŸÖŸÜ ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÖÿµŸäÿ±!")
            
            # ÿ≠ÿ≥ÿßÿ® ÿ•ÿ¨ŸÖÿßŸÑŸä ÿßŸÑŸÜŸÇÿßÿ∑ ÿ®ÿπÿØ ÿßÿÆÿ™ÿ®ÿßÿ± ÿßŸÑŸÖÿµŸäÿ±
            await ctx.send(f"ŸÜŸÇÿßÿ∑ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ÿßŸÑÿ¢ŸÜ: {game_state.red_team_points}")
            await ctx.send(f"ŸÜŸÇÿßÿ∑ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ÿßŸÑÿ¢ŸÜ: {game_state.blue_team_points}")
    
    async def handle_steal_question(self, bot, ctx, game_state):
        """Handle a steal question"""
        if game_state.game_mode == "ÿ™ÿ≠ÿØŸä":
            await self._handle_steal_challenge(bot, ctx, game_state)
        elif game_state.game_mode == "ÿ™ŸäŸÖ":
            await self._handle_steal_team(bot, ctx, game_state)
    
    async def _handle_steal_challenge(self, bot, ctx, game_state):
        """Handle steal question in challenge mode"""
        # Randomly select a player to steal points from
        if len(game_state.players) <= 1:
            await ctx.send("ŸÑÿß ŸäŸàÿ¨ÿØ ŸÑÿßÿπÿ®ŸäŸÜ ŸÉÿßŸÅŸäŸäŸÜ ŸÑŸÑÿ≤ÿ±ŸÅ!")
            return
        
        # ŸÅŸä ÿ≠ÿßŸÑÿ© Ÿàÿ¨ŸàÿØ ŸÑÿßÿπÿ®ŸäŸÜ ŸÅŸÇÿ∑ÿå ÿßÿÆÿ™ÿ± ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑÿ¢ÿÆÿ±
        if len(game_state.players) == 2:
            # ÿßÿÆÿ™ÿ± ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑÿ∞Ÿä ŸÑŸäÿ≥ ŸáŸà ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑÿ≠ÿßŸÑŸä (ÿßŸÑÿ∞Ÿä ÿ≥Ÿäÿ¨Ÿäÿ®)
            possible_targets = game_state.players.copy()
            # ÿ≥ŸÜÿÆÿ™ÿßÿ± ŸáÿØŸÅ ÿπÿ¥Ÿàÿßÿ¶Ÿä ÿßŸÑÿ¢ŸÜ Ÿàÿ≥ŸÜÿ™ÿ≠ŸÇŸÇ ŸÑÿßÿ≠ŸÇŸãÿß ŸÖŸÜ ÿ£ŸÜ ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑŸÖÿ¨Ÿäÿ® ŸÑŸäÿ≥ ŸáŸà ÿßŸÑŸáÿØŸÅ
            target_player = random.choice(possible_targets)
        else:
            # ŸÅŸä ÿ≠ÿßŸÑÿ© Ÿàÿ¨ŸàÿØ ÿ£ŸÉÿ´ÿ± ŸÖŸÜ ŸÑÿßÿπÿ®ŸäŸÜÿå ÿßÿÆÿ™ÿ± ŸÑÿßÿπÿ® ÿπÿ¥Ÿàÿßÿ¶Ÿä
            target_player = random.choice(game_state.players)
            
        await ctx.send(f"üéØ Steal Question! üéØ")
        await ctx.send(f"ÿ•ÿ∞ÿß ÿ£ÿ¨ÿ®ÿ™ ÿµÿ≠Ÿäÿ≠ÿå ÿ≥ÿ™ÿ≤ÿ±ŸÅ ŸÉŸÑ ŸÜŸÇÿßÿ∑ ÿßŸÑŸÑÿßÿπÿ® {target_player}!")
        
        question_data = self.get_random_question()
        player_name, _, _ = await self.wait_for_answer(bot, ctx, question_data, game_state)
        
        if player_name and player_name != target_player:
            # The answering player gets ALL the target's points
            stolen_points = game_state.player_points.get(target_player, 0)
            game_state.player_points[player_name] = game_state.player_points.get(player_name, 0) + stolen_points
            game_state.player_points[target_player] = 0
            
            await ctx.send(f"üî• {player_name} ÿ≤ÿ±ŸÅ {stolen_points} ŸÜŸÇÿ∑ÿ© ŸÖŸÜ {target_player}! üî•")
            await ctx.send(f"ÿ™ŸÖ ÿ™ÿµŸÅŸäÿ± ŸÜŸÇÿßÿ∑ {target_player}! üò±")
    
    async def _handle_steal_team(self, bot, ctx, game_state):
        """Handle steal question in team mode"""
        await ctx.send("üéØ Steal Question! üéØ")
        await ctx.send("ÿßŸÑŸÑŸäÿØÿ±: ÿßÿÆÿ™ÿ± 'ÿ≤ÿ±ŸÅ' ÿ£Ÿà 'ÿ≤ŸàÿØ' ŸÇÿ®ŸÑ ÿßŸÑÿ≥ÿ§ÿßŸÑ")
        
        choice_red = None
        choice_blue = None
        
        # Wait for leaders to make their choices
        def check_leader_choice(message):
            return (message.author.name == game_state.red_leader and message.content in ["ÿ≤ÿ±ŸÅ", "ÿ≤ŸàÿØ"]) or \
                   (message.author.name == game_state.blue_leader and message.content in ["ÿ≤ÿ±ŸÅ", "ÿ≤ŸàÿØ"])
        
        # Give 10 seconds for leaders to choose
        try:
            start_time = asyncio.get_event_loop().time()
            while (choice_red is None or choice_blue is None) and (asyncio.get_event_loop().time() - start_time < 10):
                remaining = 10 - (asyncio.get_event_loop().time() - start_time)
                
                try:
                    message = await bot.wait_for('message', timeout=remaining, check=check_leader_choice)
                    if message.author.name == game_state.red_leader:
                        choice_red = message.content
                        await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ÿßÿÆÿ™ÿßÿ±: {choice_red}")
                    elif message.author.name == game_state.blue_leader:
                        choice_blue = message.content
                        await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ÿßÿÆÿ™ÿßÿ±: {choice_blue}")
                except asyncio.TimeoutError:
                    break
        
        except Exception as e:
            print(f"Error waiting for leader choices: {e}")
        
        # If leaders didn't choose, assign random choices
        if choice_red is None:
            choice_red = random.choice(["ÿ≤ÿ±ŸÅ", "ÿ≤ŸàÿØ"])
            await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ŸÑŸÖ ŸäÿÆÿ™ÿ±ÿå ÿ≥Ÿäÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± {choice_red} ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß")
        
        if choice_blue is None:
            choice_blue = random.choice(["ÿ≤ÿ±ŸÅ", "ÿ≤ŸàÿØ"])
            await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ŸÑŸÖ ŸäÿÆÿ™ÿ±ÿå ÿ≥Ÿäÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± {choice_blue} ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß")
        
        # Ask the question
        question_data = self.get_random_question()
        player_name, _, _ = await self.wait_for_answer(bot, ctx, question_data, game_state)
        
        if player_name:
            # Determine which team the answering player belongs to
            if player_name in game_state.red_team:
                winning_team = "red"
                winning_choice = choice_red
                winning_leader = game_state.red_leader
            else:
                winning_team = "blue"
                winning_choice = choice_blue
                winning_leader = game_state.blue_leader
            
            # Execute the chosen action
            if winning_choice == "ÿ≤ÿ±ŸÅ":
                await ctx.send(f"{winning_leader}: ŸÖŸÜÿ¥ŸÜ ÿ¥ÿÆÿµ ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑŸÖŸÜÿßŸÅÿ≥ ŸÑÿ≤ÿ±ŸÅ ŸÜŸÇÿßÿ∑Ÿá")
                
                # Wait for the leader to mention a player
                def check_mention(message):
                    return message.author.name == winning_leader and len(message.mentions) > 0
                
                try:
                    mention_msg = await bot.wait_for('message', timeout=10, check=check_mention)
                    target_player = mention_msg.mentions[0].name
                    
                    # Check if the target is from the opposing team
                    if (winning_team == "red" and target_player in game_state.blue_team) or \
                       (winning_team == "blue" and target_player in game_state.red_team):
                        
                        # ÿ™ÿπÿØŸäŸÑ ŸÖŸÜÿ∑ŸÇ ÿ≤ÿ±ŸÅ ÿßŸÑŸÜŸÇÿßÿ∑ ŸÑŸäŸÉŸàŸÜ ŸÑŸÑÿßÿπÿ® ÿßŸÑŸÖÿ≠ÿØÿØ ŸÅŸÇÿ∑
                        # ŸÜÿ∂ŸäŸÅ ŸÇÿßÿ¶ŸÖÿ© ŸÅÿ±ÿØŸäÿ© ŸÑŸÜŸÇÿßÿ∑ ŸÉŸÑ ŸÑÿßÿπÿ® ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿ™ŸäŸÖ ÿ•ŸÜ ŸÑŸÖ ÿ™ŸÉŸÜ ŸÖŸàÿ¨ŸàÿØÿ©
                        if 'player_individual_points' not in game_state.__dict__:
                            game_state.player_individual_points = {}
                            
                        # ŸÜÿ≠ÿµŸÑ ÿπŸÑŸâ ŸÜŸÇÿßÿ∑ ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑŸÖÿ≠ÿØÿØ ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑŸÖŸÜÿßŸÅÿ≥ (ÿ•ŸÜ Ÿàÿ¨ÿØÿ™)
                        target_points = game_state.player_individual_points.get(target_player, 0)
                        
                        if target_points == 0:
                            # ÿ•ÿ∞ÿß ŸÑŸÖ ÿ™ŸÉŸÜ ŸÑŸÑÿßÿπÿ® ŸÜŸÇÿßÿ∑ÿå ÿßÿ¨ÿπŸÑŸá ŸäÿÆÿ≥ÿ± 10 ŸÜŸÇÿßÿ∑ ŸÖŸÜ ŸÅÿ±ŸäŸÇŸá
                            if winning_team == "red":
                                # ÿ≤ÿ±ŸÅ 10 ŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ
                                stolen_points = min(10, game_state.blue_team_points)
                                game_state.red_team_points += stolen_points
                                game_state.blue_team_points -= stolen_points
                                await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ÿ≤ÿ±ŸÅ {stolen_points} ŸÜŸÇÿ∑ÿ© ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ŸÑÿ£ŸÜ {target_player} ŸÑŸäÿ≥ ŸÑÿØŸäŸá ŸÜŸÇÿßÿ∑ ŸÅÿ±ÿØŸäÿ©!")
                            else:
                                # ÿ≤ÿ±ŸÅ 10 ŸÜŸÇÿßÿ∑ ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ±
                                stolen_points = min(10, game_state.red_team_points)
                                game_state.blue_team_points += stolen_points
                                game_state.red_team_points -= stolen_points
                                await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ÿ≤ÿ±ŸÅ {stolen_points} ŸÜŸÇÿ∑ÿ© ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ŸÑÿ£ŸÜ {target_player} ŸÑŸäÿ≥ ŸÑÿØŸäŸá ŸÜŸÇÿßÿ∑ ŸÅÿ±ÿØŸäÿ©!")
                        else:
                            # ÿ≤ÿ±ŸÅ ŸÜŸÇÿßÿ∑ ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑŸÖÿ≥ÿ™ŸáÿØŸÅ
                            if winning_team == "red":
                                # ÿ≤ÿ±ŸÅ ŸÜŸÇÿßÿ∑ ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑŸÖÿ≥ÿ™ŸáÿØŸÅ ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ
                                game_state.red_team_points += target_points
                                game_state.blue_team_points -= target_points
                                game_state.player_individual_points[target_player] = 0
                                await ctx.send(f"üî• ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ÿ≤ÿ±ŸÅ {target_points} ŸÜŸÇÿ∑ÿ© ŸÖŸÜ {target_player}! üî•")
                                await ctx.send(f"ÿ™ŸÖ ÿ™ÿµŸÅŸäÿ± ŸÜŸÇÿßÿ∑ {target_player} ÿßŸÑŸÅÿ±ÿØŸäÿ©! üò±")
                            else:
                                # ÿ≤ÿ±ŸÅ ŸÜŸÇÿßÿ∑ ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑŸÖÿ≥ÿ™ŸáÿØŸÅ ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ±
                                game_state.blue_team_points += target_points
                                game_state.red_team_points -= target_points
                                game_state.player_individual_points[target_player] = 0
                                await ctx.send(f"üî• ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ÿ≤ÿ±ŸÅ {target_points} ŸÜŸÇÿ∑ÿ© ŸÖŸÜ {target_player}! üî•")
                                await ctx.send(f"ÿ™ŸÖ ÿ™ÿµŸÅŸäÿ± ŸÜŸÇÿßÿ∑ {target_player} ÿßŸÑŸÅÿ±ÿØŸäÿ©! üò±")
                    else:
                        await ctx.send("Ÿáÿ∞ÿß ÿßŸÑŸÑÿßÿπÿ® ŸÑŸäÿ≥ ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑŸÖŸÜÿßŸÅÿ≥!")
                
                except asyncio.TimeoutError:
                    await ctx.send("ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™ÿå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± ŸÑÿßÿπÿ® ŸÑŸÑÿ≤ÿ±ŸÅ")
            
            elif winning_choice == "ÿ≤ŸàÿØ":
                # Add random points between 0 and 30
                bonus_points = random.randint(0, 30)
                
                if winning_team == "red":
                    game_state.red_team_points += bonus_points
                    await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ÿ≠ÿµŸÑ ÿπŸÑŸâ {bonus_points} ŸÜŸÇÿ∑ÿ© ÿ•ÿ∂ÿßŸÅŸäÿ© ŸÖŸÜ ÿßŸÑÿ≠ÿ∏!")
                else:
                    game_state.blue_team_points += bonus_points
                    await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ÿ≠ÿµŸÑ ÿπŸÑŸâ {bonus_points} ŸÜŸÇÿ∑ÿ© ÿ•ÿ∂ÿßŸÅŸäÿ© ŸÖŸÜ ÿßŸÑÿ≠ÿ∏!")

    async def handle_doom_question(self, bot, ctx, game_state):
        """Handle a Doom question that can double points or lose all points"""
        # ÿ≥ÿ§ÿßŸÑ ÿßŸÑÿØŸàŸÖ ŸÖÿ™ÿßÿ≠ ŸÅŸÇÿ∑ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿ™ŸäŸÖ
        if game_state.game_mode != "ÿ™ŸäŸÖ":
            await ctx.send("ÿ≥ÿ§ÿßŸÑ Doom ŸÖÿ™ÿßÿ≠ ŸÅŸÇÿ∑ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿ™ŸäŸÖ!")
            return
            
        await ctx.send("‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è Doom Question! ‚ò†Ô∏è‚ò†Ô∏è‚ò†Ô∏è")
        await ctx.send("Ÿáÿ∞ÿß ÿ≥ÿ§ÿßŸÑ Doom ŸÑŸÉ ÿßŸÑŸÇÿ±ÿßÿ± ÿ™ÿ¨ÿßŸàÿ® ÿßŸà ÿ™ŸÜÿ≥ÿ≠ÿ®")
        await ctx.send("ÿπŸÜÿØ ÿßŸÑÿßÿ¨ÿßÿ®ÿ© ÿßŸÑÿÆÿßÿ∑ÿ¶ÿ© ÿßŸà ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑŸàŸÇÿ™ ŸäÿÆÿ≥ÿ± ÿßŸÑŸÅÿ±ŸäŸÇ ŸÉŸÑ ŸÜŸÇÿßÿ∑Ÿá Ÿàÿ™ŸÜÿ™ŸáŸä ÿßŸÑŸÑÿπÿ®ÿ©")
        await ctx.send("ÿßŸÉÿ™ÿ® 1 ŸÑŸÑŸÇÿ®ŸàŸÑ ÿ£Ÿà 2 ŸÑŸÑÿ±ŸÅÿ∂")
        
        # ŸÖÿ™ÿ∫Ÿäÿ±ÿßÿ™ ÿÆÿßÿµÿ© ÿ®ÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ŸÇÿßÿØÿ© ÿßŸÑŸÅÿ±ŸÇ
        red_accept = None
        blue_accept = None
        
        # ÿØÿßŸÑÿ© ŸÑŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ŸÇÿßÿØÿ© ÿßŸÑŸÅÿ±ŸÇ
        def check_leader_choice(message):
            return (message.author.name == game_state.red_leader and message.content in ["1", "2"]) or \
                   (message.author.name == game_state.blue_leader and message.content in ["1", "2"])
        
        # ÿßŸÜÿ™ÿ∏ÿßÿ± ÿßÿÆÿ™Ÿäÿßÿ±ÿßÿ™ ŸÇÿßÿØÿ© ÿßŸÑŸÅÿ±ŸÇ - 10 ÿ´ŸàÿßŸÜŸä
        try:
            start_time = asyncio.get_event_loop().time()
            timeout_duration = 10
            
            while (red_accept is None or blue_accept is None) and (asyncio.get_event_loop().time() - start_time < timeout_duration):
                remaining = timeout_duration - (asyncio.get_event_loop().time() - start_time)
                
                try:
                    message = await bot.wait_for('message', timeout=remaining, check=check_leader_choice)
                    
                    if message.author.name == game_state.red_leader:
                        red_accept = message.content == "1"
                        await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± {'ŸÇÿ®ŸÑ' if red_accept else 'ÿ±ŸÅÿ∂'} ÿ≥ÿ§ÿßŸÑ Doom!")
                    elif message.author.name == game_state.blue_leader:
                        blue_accept = message.content == "1"
                        await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ {'ŸÇÿ®ŸÑ' if blue_accept else 'ÿ±ŸÅÿ∂'} ÿ≥ÿ§ÿßŸÑ Doom!")
                
                except asyncio.TimeoutError:
                    # ÿ•ÿ∞ÿß ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™ ŸàŸÑŸÖ ŸäÿÆÿ™ÿ± ÿ£ÿ≠ÿØ ÿßŸÑŸÇÿßÿØÿ©ÿå ÿßŸÑÿÆÿ±Ÿàÿ¨ ŸÖŸÜ ÿßŸÑÿ≠ŸÑŸÇÿ©
                    break
        
        except Exception as e:
            # ÿ™ÿ≥ÿ¨ŸäŸÑ ÿßŸÑÿÆÿ∑ÿ£ ŸÑŸÑŸÖÿ∑Ÿàÿ±ŸäŸÜ ŸÅŸÇÿ∑
            print(f"Error in handle_doom_question: {e}")
        
        # ÿ™ÿπŸäŸäŸÜ ÿ±ŸÅÿ∂ ÿßŸÅÿ™ÿ±ÿßÿ∂Ÿä ŸÑŸÑŸÅÿ±ŸÇ ÿßŸÑÿ™Ÿä ŸÑŸÖ ÿ™ÿÆÿ™ÿ±
        if red_accept is None:
            red_accept = False
            await ctx.send("ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ŸÑŸÖ Ÿäÿ±ÿØÿå ÿ≥Ÿäÿ™ŸÖ ÿßÿπÿ™ÿ®ÿßÿ± ÿ∞ŸÑŸÉ ÿ±ŸÅÿ∂Ÿãÿß")
            
        if blue_accept is None:
            blue_accept = False
            await ctx.send("ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ŸÑŸÖ Ÿäÿ±ÿØÿå ÿ≥Ÿäÿ™ŸÖ ÿßÿπÿ™ÿ®ÿßÿ± ÿ∞ŸÑŸÉ ÿ±ŸÅÿ∂Ÿãÿß")
        
        # ŸÖÿπÿßŸÑÿ¨ÿ© ÿ≥ÿ§ÿßŸÑ ÿßŸÑÿØŸàŸÖ ŸÑŸÑŸÅÿ±ŸÇ ÿßŸÑÿ™Ÿä ŸÇÿ®ŸÑÿ™ ÿßŸÑÿ™ÿ≠ÿØŸä
        if red_accept:
            await self._process_doom_for_team(bot, ctx, game_state, "red")
            
        if blue_accept:
            await self._process_doom_for_team(bot, ctx, game_state, "blue")
            
        # ÿ•ÿ∞ÿß ÿ±ŸÅÿ∂ ŸÉŸÑÿß ÿßŸÑŸÅÿ±ŸäŸÇŸäŸÜÿå ÿ£ÿÆÿ®ÿ± ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ŸàŸÜÿ≥ÿ™ŸÖÿ±
        if not red_accept and not blue_accept:
            await ctx.send("ŸÉŸÑÿß ÿßŸÑŸÅÿ±ŸäŸÇŸäŸÜ ÿ±ŸÅÿ∂ÿß ÿ≥ÿ§ÿßŸÑ Doom! ÿØÿπŸàŸÜÿß ŸÜÿ≥ÿ™ŸÖÿ±!")
    
    async def _process_doom_for_team(self, bot, ctx, game_state, team):
        """Process the doom question for a specific team"""
        question_data = self.get_random_question()
        
        team_name = "ÿßŸÑÿ£ÿ≠ŸÖÿ±" if team == "red" else "ÿßŸÑÿ£ÿ≤ÿ±ŸÇ"
        leader_name = game_state.red_leader if team == "red" else game_state.blue_leader
        
        await ctx.send(f"ÿ≥ÿ§ÿßŸÑ Doom ŸÑŸÑŸÅÿ±ŸäŸÇ {team_name}:")
        await ctx.send(f"ŸÅŸÇÿ∑ {leader_name} ŸäŸÖŸÉŸÜŸá ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ©!")
        
        await ctx.send(question_data["question"])
        
        # Only accept answers from the team leader
        def check_leader_answer(message):
            return message.author.name == leader_name
        
        try:
            # Give the leader 10 seconds to answer
            message = await bot.wait_for('message', timeout=10, check=check_leader_answer)
            
            # Check if the answer is correct
            if self.check_answer(message.content, question_data["answer"]):
                # Double the team's points
                if team == "red":
                    game_state.red_team_points *= 2
                    await ctx.send(f"ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©! ŸÜŸÇÿßÿ∑ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ÿ™ÿ∂ÿßÿπŸÅÿ™ ÿ•ŸÑŸâ {game_state.red_team_points}!")
                else:
                    game_state.blue_team_points *= 2
                    await ctx.send(f"ÿ•ÿ¨ÿßÿ®ÿ© ÿµÿ≠Ÿäÿ≠ÿ©! ŸÜŸÇÿßÿ∑ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ÿ™ÿ∂ÿßÿπŸÅÿ™ ÿ•ŸÑŸâ {game_state.blue_team_points}!")
            else:
                # Wrong answer, lose all points and end the game (the other team wins)
                if team == "red":
                    game_state.red_team_points = 0
                    await ctx.send(f"ÿ•ÿ¨ÿßÿ®ÿ© ÿÆÿßÿ∑ÿ¶ÿ©! ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ÿÆÿ≥ÿ± ŸÉŸÑ ŸÜŸÇÿßÿ∑Ÿá!")
                    await ctx.send(f"ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©! ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ŸáŸà ÿßŸÑŸÅÿßÿ¶ÿ≤! üèÜ")
                    
                    # ÿ•ŸÜŸáÿßÿ° ÿßŸÑŸÑÿπÿ®ÿ© Ÿàÿ•ÿπŸÑÿßŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ŸÉŸÅÿßÿ¶ÿ≤
                    game_state.game_over = True
                    game_state.winning_team = "blue"
                else:
                    game_state.blue_team_points = 0
                    await ctx.send(f"ÿ•ÿ¨ÿßÿ®ÿ© ÿÆÿßÿ∑ÿ¶ÿ©! ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ÿÆÿ≥ÿ± ŸÉŸÑ ŸÜŸÇÿßÿ∑Ÿá!")
                    await ctx.send(f"ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©! ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ŸáŸà ÿßŸÑŸÅÿßÿ¶ÿ≤! üèÜ")
                    
                    # ÿ•ŸÜŸáÿßÿ° ÿßŸÑŸÑÿπÿ®ÿ© Ÿàÿ•ÿπŸÑÿßŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ŸÉŸÅÿßÿ¶ÿ≤
                    game_state.game_over = True
                    game_state.winning_team = "red"
                
                await ctx.send(f"ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸÉÿßŸÜÿ™: {question_data['answer']}")
        
        except asyncio.TimeoutError:
            # Time's up, lose all points and end the game (the other team wins)
            if team == "red":
                game_state.red_team_points = 0
                await ctx.send(f"ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™! ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ÿÆÿ≥ÿ± ŸÉŸÑ ŸÜŸÇÿßÿ∑Ÿá!")
                await ctx.send(f"ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©! ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ŸáŸà ÿßŸÑŸÅÿßÿ¶ÿ≤! üèÜ")
                
                # ÿ•ŸÜŸáÿßÿ° ÿßŸÑŸÑÿπÿ®ÿ© Ÿàÿ•ÿπŸÑÿßŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ŸÉŸÅÿßÿ¶ÿ≤
                game_state.game_over = True
                game_state.winning_team = "blue"
            else:
                game_state.blue_team_points = 0
                await ctx.send(f"ÿßŸÜÿ™ŸáŸâ ÿßŸÑŸàŸÇÿ™! ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ÿÆÿ≥ÿ± ŸÉŸÑ ŸÜŸÇÿßÿ∑Ÿá!")
                await ctx.send(f"ÿßŸÜÿ™Ÿáÿ™ ÿßŸÑŸÑÿπÿ®ÿ©! ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ŸáŸà ÿßŸÑŸÅÿßÿ¶ÿ≤! üèÜ")
                
                # ÿ•ŸÜŸáÿßÿ° ÿßŸÑŸÑÿπÿ®ÿ© Ÿàÿ•ÿπŸÑÿßŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ŸÉŸÅÿßÿ¶ÿ≤
                game_state.game_over = True
                game_state.winning_team = "red"
            
            await ctx.send(f"ÿßŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿßŸÑÿµÿ≠Ÿäÿ≠ÿ© ŸÉÿßŸÜÿ™: {question_data['answer']}")

    async def handle_sabotage_question(self, bot, ctx, game_state):
        """Handle a sabotage question to eliminate a player from the opposing team"""
        if game_state.game_mode != "ÿ™ŸäŸÖ":
            await ctx.send("ÿ≥ÿ§ÿßŸÑ ÿßŸÑÿßÿ≥ÿ™ÿ®ÿπÿßÿØ ŸÖÿ™ÿßÿ≠ ŸÅŸÇÿ∑ ŸÅŸä Ÿàÿ∂ÿπ ÿßŸÑÿ™ŸäŸÖ!")
            return
        
        await ctx.send("üî• Sabotage Question! üî•")
        await ctx.send("ÿßÿÆÿ™ÿ± ÿ¥ÿÆÿµŸãÿß ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ¢ÿÆÿ± ÿ™ÿ±ÿ∫ÿ® ŸÅŸä ÿßÿ≥ÿ™ÿ®ÿπÿßÿØŸá ŸÖŸÜ ÿßŸÑŸÑÿπÿ®ÿ©ÿå ŸÇŸÖ ÿ®ÿπŸÖŸÑ ŸÖŸÜÿ¥ŸÜ ŸÑŸá.")
        
        # Wait for each team to choose a player to sabotage
        red_target = None
        blue_target = None
        
        start_time = asyncio.get_event_loop().time()
        
        # Function to check valid mentions
        def check_valid_mention(message):
            if message.author.name == game_state.red_leader and message.mentions:
                # Red leader should mention someone from blue team
                return message.mentions[0].name in game_state.blue_team
            elif message.author.name == game_state.blue_leader and message.mentions:
                # Blue leader should mention someone from red team
                return message.mentions[0].name in game_state.red_team
            return False
        
        # Give 15 seconds for leaders to make their choices
        while (red_target is None or blue_target is None) and (asyncio.get_event_loop().time() - start_time < 15):
            remaining = 15 - (asyncio.get_event_loop().time() - start_time)
            
            try:
                message = await bot.wait_for('message', timeout=remaining, check=check_valid_mention)
                
                if message.author.name == game_state.red_leader:
                    red_target = message.mentions[0].name
                    await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ÿßÿÆÿ™ÿßÿ± ÿßÿ≥ÿ™ÿ®ÿπÿßÿØ {red_target} ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ!")
                elif message.author.name == game_state.blue_leader:
                    blue_target = message.mentions[0].name
                    await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ÿßÿÆÿ™ÿßÿ± ÿßÿ≥ÿ™ÿ®ÿπÿßÿØ {blue_target} ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ±!")
            
            except asyncio.TimeoutError:
                break
        
        # If a team didn't choose, select random targets
        if red_target is None and game_state.blue_team:
            red_target = random.choice(game_state.blue_team)
            await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ŸÑŸÖ ŸäÿÆÿ™ÿ±ÿå ÿ≥Ÿäÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± {red_target} ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ÿπÿ¥Ÿàÿßÿ¶ŸäŸãÿß!")
        
        if blue_target is None and game_state.red_team:
            blue_target = random.choice(game_state.red_team)
            await ctx.send(f"ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ ŸÑŸÖ ŸäÿÆÿ™ÿ±ÿå ÿ≥Ÿäÿ™ŸÖ ÿßÿÆÿ™Ÿäÿßÿ± {blue_target} ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ± ÿπÿ¥Ÿàÿßÿ¶ŸäŸãÿß!")
        
        # Now ask the sabotage question
        await ctx.send("ÿßŸÑÿ¢ŸÜÿå ŸÑŸÑÿ•ÿ¨ÿßÿ®ÿ© ÿπŸÑŸâ ÿßŸÑÿ≥ÿ§ÿßŸÑÿå ÿ£ŸàŸÑ ŸÖŸÜ Ÿäÿ¨Ÿäÿ® ÿµÿ≠ ÿ≥Ÿäÿ≥ÿ™ÿ®ÿπÿØ ÿßŸÑŸÑÿßÿπÿ® ÿßŸÑÿ∞Ÿä ÿ™ŸÖ ŸÖŸÜÿ¥ŸÜŸá.")
        
        question_data = self.get_random_question()
        player_name, _, _ = await self.wait_for_answer(bot, ctx, question_data, game_state)
        
        if player_name:
            # Determine which player gets eliminated based on who answered
            if player_name in game_state.red_team and blue_target:
                eliminated_player = blue_target
                elimination_messages = self._get_elimination_messages()
                game_state.blue_team.remove(blue_target)
                await ctx.send(f"{elimination_messages} {eliminated_player} ÿ™ŸÖ ÿßÿ≥ÿ™ÿ®ÿπÿßÿØŸá ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≤ÿ±ŸÇ!")
            
            elif player_name in game_state.blue_team and red_target:
                eliminated_player = red_target
                elimination_messages = self._get_elimination_messages()
                game_state.red_team.remove(red_target)
                await ctx.send(f"{elimination_messages} {eliminated_player} ÿ™ŸÖ ÿßÿ≥ÿ™ÿ®ÿπÿßÿØŸá ŸÖŸÜ ÿßŸÑŸÅÿ±ŸäŸÇ ÿßŸÑÿ£ÿ≠ŸÖÿ±!")
    
    def _get_elimination_messages(self):
        """Get a random elimination message"""
        from config import ELIMINATION_MESSAGES
        return random.choice(ELIMINATION_MESSAGES)
